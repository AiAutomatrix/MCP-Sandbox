{
  "entities": {
    "AgentLogStep": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AgentLogStep",
      "type": "object",
      "description": "Stores a single log step for a message handled by the agent, associated with a specific session.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the log step."
        },
        "sessionId": {
          "type": "string",
          "description": "Reference to AgentSession. (Relationship: AgentSession 1:N AgentLogStep)"
        },
        "timestamp": {
          "type": "string",
          "description": "Timestamp of when the step occurred.",
          "format": "date-time"
        },
        "userMessage": {
          "type": "string",
          "description": "The user message that initiated this step."
        },
        "modelResponse": {
          "type": "string",
          "description": "The model's response for this step."
        },
        "reasoning": {
          "type": "string",
          "description": "The model's reasoning for this step."
        },
        "toolCalls": {
          "type": "array",
          "description": "List of tool calls made in this step.",
          "items": {
            "type": "string"
          }
        },
        "toolResults": {
          "type": "string",
          "description": "Results from the tool calls made in this step."
        },
        "finalResponse": {
          "type": "string",
          "description": "The final response from the model after tool execution (if any)."
        }
      },
      "required": [
        "id",
        "sessionId",
        "timestamp",
        "userMessage",
        "modelResponse",
        "reasoning"
      ]
    },
    "AgentMemoryFact": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AgentMemoryFact",
      "type": "object",
      "description": "Represents a fact stored in the agent's memory for a specific session.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the memory fact."
        },
        "sessionId": {
          "type": "string",
          "description": "Reference to AgentSession. (Relationship: AgentSession 1:N AgentMemoryFact)"
        },
        "text": {
          "type": "string",
          "description": "The text content of the fact."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp of when the fact was created.",
          "format": "date-time"
        },
        "source": {
          "type": "string",
          "description": "The source of the fact (tool, user, or agent)."
        }
      },
      "required": [
        "id",
        "sessionId",
        "text",
        "createdAt",
        "source"
      ]
    },
    "ToolData": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ToolData",
      "type": "object",
      "description": "Stores data generated by a specific tool.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the tool data."
        },
        "toolName": {
          "type": "string",
          "description": "Name of the tool that generated this data."
        },
        "data": {
          "type": "string",
          "description": "The data stored by the tool (can be a JSON string or other serialized format)."
        }
      },
      "required": [
        "id",
        "toolName",
        "data"
      ]
    },
    "AgentSession": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "AgentSession",
      "type": "object",
      "description": "Represents a session of interaction with the agent.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the agent session."
        },
        "startTime": {
          "type": "string",
          "description": "Timestamp of when the session started.",
          "format": "date-time"
        },
        "endTime": {
          "type": "string",
          "description": "Timestamp of when the session ended (if applicable).",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "startTime"
      ]
    },
    "TodoItem": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "TodoItem",
      "type": "object",
      "description": "Represents a to-do item managed by the TodoTool.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the to-do item."
        },
        "text": {
          "type": "string",
          "description": "The text description of the to-do item."
        },
        "completed": {
          "type": "boolean",
          "description": "Indicates whether the to-do item is completed."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp of when the to-do item was created.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "text",
        "completed",
        "createdAt"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/agent_logs/{sessionId}/steps/{stepId}",
        "definition": {
          "entityName": "AgentLogStep",
          "schema": {
            "$ref": "#/backend/entities/AgentLogStep"
          },
          "description": "Stores visible logs for every message handled by the agent, associated with a specific session.  Owned by the user, implicitly authorized through the sessionId. Includes denormalized 'sessionId' for authorization independence.",
          "params": [
            {
              "name": "sessionId",
              "description": "The ID of the agent session."
            },
            {
              "name": "stepId",
              "description": "The ID of the log step."
            }
          ]
        }
      },
      {
        "path": "/agent_memory/{sessionId}/facts/{factId}",
        "definition": {
          "entityName": "AgentMemoryFact",
          "schema": {
            "$ref": "#/backend/entities/AgentMemoryFact"
          },
          "description": "Agent-level memory for an agent session.  Owned by the user, implicitly authorized through the sessionId. Includes denormalized 'sessionId' for authorization independence.",
          "params": [
            {
              "name": "sessionId",
              "description": "The ID of the agent session."
            },
            {
              "name": "factId",
              "description": "The ID of the memory fact."
            }
          ]
        }
      },
      {
        "path": "/tool_memory/{toolName}/{dataId}",
        "definition": {
          "entityName": "ToolData",
          "schema": {
            "$ref": "#/backend/entities/ToolData"
          },
          "description": "Stores data generated by a specific tool. Segregated by tool name. Owned by the user. Includes denormalized 'toolName' for authorization independence.",
          "params": [
            {
              "name": "toolName",
              "description": "The name of the tool."
            },
            {
              "name": "dataId",
              "description": "The ID of the tool data."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to support the MCP agent sandbox with memory, logging, and tool data. It emphasizes authorization independence and simplifies security rules. The core principle is to avoid using `get()` calls in security rules by denormalizing authorization data where needed.  Each collection serves a distinct purpose with clear naming conventions for easy debugging and maintenance. Path-based ownership and segregation are applied wherever possible.\n\nAuthorization Independence: Since all the collections are user-owned, the structure doesn't require `get()` calls to parent documents to determine authorization. If collaboration was required, membership maps would be added to relevant documents.\n\nQAPs (Rules are not Filters):  The structure enables secure `list` operations by ensuring that each collection contains documents with homogeneous security needs. For instance, agent logs and memory are segregated by session, preventing unauthorized access to other sessions' data. The `tool_memory` collection is segregated by tool name, allowing specific access rules per tool, if required.\n\nEach path adheres to a consistent naming convention and includes descriptions clarifying its purpose and denormalized authorization fields."
  }
}