'use server';
/**
 * generate-response-with-tools.ts
 *
 * This file defines the core AI flow for the Gemini Sandbox application.
 * It is responsible for generating a response from the model based on user input,
 * conversation memory, and available tools.
 *
 * Key features:
 * - **Tool-Aware:** It can request the execution of predefined tools (like `mathEvaluator` or `todoTool`).
 * - **Memory-Aware:** It takes into account facts from the current conversation.
 * - **Step-by-Step Execution:** Unlike a fully self-contained loop, this flow executes ONE step at a time.
 *   If the model requests a tool, the flow returns the `toolRequest` to the calling action. The action
 *   is then responsible for executing the tool and calling this flow again with the `toolResponse`.
 *
 * This design allows the controlling server action to have full visibility and log each step of the agent's
 * reasoning and tool-use process.
 */

import { ai } from '@/ai/genkit';
import { z } from 'genkit';
import * as admin from 'firebase-admin';

// Initialize firebase-admin (safe to call multiple times)
if (!admin.apps.length) {
  try {
    admin.initializeApp();
  } catch (e) {
    // ignore double init in non-cloud-run environments
  }
}
export const db = admin.firestore();

// -----------------------------
// Tool Definitions
// -----------------------------

export const mathEvaluator = ai.defineTool(
  {
    name: 'mathEvaluator',
    description:
      'Evaluates a simple mathematical expression. (demo only; eval used for speed)',
    inputSchema: z.object({
      expression: z
        .string()
        .describe('A simple JS math expression like "2+2*3"'),
    }),
    outputSchema: z.any(),
  },
  async (input) => {
    try {
      // WARNING: eval() is unsafe for arbitrary input. This is a dev-only tool.
      // Replace with a proper math parser (mathjs) in prod.
      const result = eval(input.expression);
      return { result: String(result) };
    } catch (err: any) {
      return {
        error: `Error evaluating expression: ${err?.message ?? String(err)}`,
      };
    }
  }
);

export const todoTool = ai.defineTool(
  {
    name: 'todoTool',
    description:
      'Simple Firestore-backed todo tool. Actions: add, list, complete. Uses sessionId to namespace todos.',
    inputSchema: z.object({
      action: z
        .enum(['add', 'list', 'complete'])
        .describe('Action to perform on todos'),
      sessionId: z
        .string()
        .optional()
        .describe('Optional sessionId to scope todos'),
      text: z.string().optional().describe('Text for add action'),
      id: z.string().optional().describe('ID for complete action'),
    }),
    outputSchema: z.any(),
  },
  async (input) => {
    const collectionBase = 'tool_memory/todoTool/items';
    try {
      if (input.action === 'add') {
        if (!input.text) return { error: 'Missing text for add action' };
        const docRef = await db.collection(collectionBase).add({
          text: input.text,
          completed: false,
          sessionId: input.sessionId || null,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
        return { ok: true, id: docRef.id, text: input.text };
      }

      if (input.action === 'list') {
        let q = db
          .collection(collectionBase)
          .orderBy('createdAt', 'desc')
          .limit(200);
        if (input.sessionId) q = q.where('sessionId', '==', input.sessionId);
        const snap = await q.get();
        const items = snap.docs.map((d) => ({
          id: d.id,
          ...(d.data() as any),
        }));
        return { items };
      }

      if (input.action === 'complete') {
        if (!input.id) return { error: 'Missing id for complete action' };
        const ref = db.collection(collectionBase).doc(input.id);
        await ref.update({ completed: true });
        return { ok: true, id: input.id };
      }

      return { error: 'Unknown action' };
    } catch (err: any) {
      return { error: err?.message ?? String(err) };
    }
  }
);

// Tool registry for runtime execution
export const TOOL_REGISTRY: Record<string, any> = {
  mathEvaluator,
  todoTool,
};

// -----------------------------
// Schemas
// -----------------------------

const ToolRequestSchema = z.object({
  name: z.string().describe('Tool name to call'),
  input: z.any().optional().describe('Tool input payload'),
});

const GenerateResponseInputSchema = z.object({
  userMessage: z.string().describe('The user message to be processed.'),
  memory: z
    .array(z.string())
    .describe('A list of facts the agent has remembered from the conversation.'),
  toolResponse: z
    .any()
    .optional()
    .describe('Optional result from a tool run (for tool loops)'),
});
export type GenerateResponseInput = z.infer<typeof GenerateResponseInputSchema>;

const GenerateResponseOutputSchema = z.object({
  response: z.string().optional().describe('The response generated by the model.'),
  reasoning: z
    .string()
    .optional()
    .describe('The step-by-step reasoning process of the model.'),
  newFacts: z
    .array(z.string())
    .optional()
    .describe('New facts to save to memory.'),
  toolRequest: ToolRequestSchema.optional().describe(
    'Optional suggested tool request (model asks the runtime to run a tool)'
  ),
});
export type GenerateResponseOutput = z.infer<
  typeof GenerateResponseOutputSchema
>;

// -----------------------------
// Prompt
// -----------------------------

const generateResponsePrompt = ai.definePrompt({
  name: 'generateResponseWithToolsPrompt',
  input: { schema: GenerateResponseInputSchema },
  output: { schema: GenerateResponseOutputSchema },
  prompt: `You are a helpful assistant with memory and access to tools.

You are given:
- A list of memory facts (use them if relevant).
- The user's message.
- Optionally, the result of a previously-run tool in 'toolResponse'.

Your goals:
1. Answer the user's message directly and conversationally.
2. If you *need* external actions or data (math, todo operations), request a tool by returning a structured object in 'toolRequest'.
   e.g., { "toolRequest": { "name": "mathEvaluator", "input": { "expression": "2+2" } } }

   If you request a tool, **do not** also provide the final user-facing \`response\`. The runtime will execute the tool and feed the result back to you. After receiving the \`toolResponse\`, you can then formulate the final answer.

3. Provide \`reasoning\` (brief) explaining how you answered or why you requested the tool.
4. Return \`newFacts\` â€” small, useful facts to save to memory (or an empty array).

Remember:
- If \`toolResponse\` is present, incorporate it into your reasoning and provide a final user-facing \`response\`.
- Only request tools when absolutely necessary. If the user is just chatting, have a normal conversation.

Current Memory/Facts:
{{#if memory}}
{{#each memory}}
- {{{this}}}
{{/each}}
{{else}}
- Memory is empty.
{{/if}}

User message:
{{{userMessage}}}

Previous tool result (if any):
{{#if toolResponse}}
{{{toolResponse}}}
{{else}}
- none
{{/if}}
`,
});

// -----------------------------
// Flow (executes a single step)
// -----------------------------
export async function generateResponse(
  input: GenerateResponseInput
): Promise<GenerateResponseOutput> {
  const { output } = await generateResponsePrompt(input);
  if (!output) {
    throw new Error('No output from model');
  }
  return output;
}
