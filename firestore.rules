/**
 * This ruleset enforces a strict user-ownership model for a conversational agent application.
 *
 * Core Philosophy:
 * The security model ensures that all user-generated data, including to-do items, session history,
 * agent logs, and memory facts, is strictly private. A user can only access and manage their own
 * data. There is no concept of public or shared data between users.
 *
 * Data Structure:
 * All user-specific data is hierarchically nested under the `/users/{userId}` path. This includes
 * subcollections like `/todos`, and `/sessions`, with sessions further containing `/steps` and `/facts`.
 * This structure leverages path-based security, making authorization rules simple and performant.
 * A separate top-level collection, `/tool_memory`, is used for server-side operations and is completely
 * inaccessible to clients.
 *
 * Key Security Decisions:
 * - Strict Ownership: All access to data under `/users/{userId}` is gated by checking if the
 *   authenticated user's ID matches the `{userId}` in the path.
 * - No User Listing: It is not possible to list documents in the top-level `/users` collection.
 * - Server-Only Collection: The `/tool_memory` collection is locked down from all client-side
 *   read and write operations, as it is intended for use by a backend service account only.
 * - Path-Based Security: Authorization relies exclusively on the document path, avoiding costly
 *   `get()` calls to parent documents for access control checks. This is a core principle of the
 *   "Authorization Independence" mentioned in the application design.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    
    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }
    
    /**
     * Checks if the authenticated user's UID matches the provided userId from the path.
     * This is the primary function for enforcing the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * For state-changing operations (update, delete), ensures the user is the owner
     * AND the document actually exists before allowing the operation.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for a user's own document in the 'users' collection.
     * @path /users/{userId}
     * @allow A signed-in user (auth.uid='user_abc') can create their own document at `/users/user_abc`.
     * @deny A user (auth.uid='user_abc') is denied from getting another user's document at `/users/user_xyz`.
     * @principle Establishes the foundation of the user-ownership model by securing the root user document.
     */
    match /users/{userId} {
      // READ: Allow owner to read their own user document.
      allow get: if isOwner(userId);

      // WRITE: Allow owner to create, update, and delete their own document.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);

      // DENY: Explicitly deny listing all users.
      allow list: if false;
    }

    /**
     * @description Rules for a user's to-do items.
     * @path /users/{userId}/todos/{todoId}
     * @allow A signed-in user (auth.uid='user_abc') can (create) their own todo at `/users/user_abc/todos/todo_123`.
     * @deny A user (auth.uid='user_abc') is denied from (get)ting a todo at `/users/user_xyz/todos/todo_456`.
     * @principle Restricts access to a user's own data tree, enforcing strict data privacy.
     */
    match /users/{userId}/todos/{todoId} {
      // READ: Allow owner to read their own todos, individually or as a list.
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      // WRITE: Allow owner to create, update, and delete their own todos.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for a user's session documents. Sessions are containers for agent interactions.
     * @path /users/{userId}/sessions/{sessionId}
     * @allow A signed-in user (auth.uid='user_abc') can (list) their own sessions at `/users/user_abc/sessions`.
     * @deny A user (auth.uid='user_abc') is denied from (create)ing a session at `/users/user_xyz/sessions/session_456`.
     * @principle Restricts access to a user's own data tree, enforcing strict data privacy.
     */
    match /users/{userId}/sessions/{sessionId} {
      // READ: Allow owner to read their own sessions.
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      // WRITE: Allow owner to manage their own sessions.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for Agent Log Steps, which are detailed logs within a user's session.
     * @path /users/{userId}/sessions/{sessionId}/steps/{stepId}
     * @allow A signed-in user (auth.uid='user_abc') can (get) a log step from their own session at `/users/user_abc/sessions/session_123/steps/step_789`.
     * @deny An anonymous user is denied from (list)ing steps at `/users/user_abc/sessions/session_123/steps`.
     * @principle Enforces ownership based on the top-level `{userId}` in the path, ensuring session data remains private.
     */
    match /users/{userId}/sessions/{sessionId}/steps/{stepId} {
      // READ: Allow owner to read logs within their own sessions.
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      // WRITE: Allow owner to create, update, and delete logs within their own sessions.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for Agent Memory Facts, which are facts learned by the agent during a session.
     * @path /users/{userId}/sessions/{sessionId}/facts/{factId}
     * @allow A signed-in user (auth.uid='user_abc') can (create) a fact in their own session at `/users/user_abc/sessions/session_123/facts/fact_789`.
     * @deny A user (auth.uid='user_abc') is denied from (delete)ing a fact in another user's session `/users/user_xyz/sessions/session_456/facts/fact_123`.
     * @principle Enforces ownership based on the top-level `{userId}` in the path, ensuring agent memory remains private.
     */
    match /users/{userId}/sessions/{sessionId}/facts/{factId} {
      // READ: Allow owner to read facts from their own sessions.
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);

      // WRITE: Allow owner to manage facts within their own sessions.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for tool-specific memory. This collection is for backend use only.
     * @path /tool_memory/{toolName}/{dataId}
     * @allow No client operation is permitted. All requests will be denied.
     * @deny A signed-in user (auth.uid='user_abc') is denied from (get)ting a document at `/tool_memory/calculator/calc_123`.
     * @principle Denies all client-side access to collections managed exclusively by a server-side service account.
     */
    match /tool_memory/{toolName}/{dataId} {
      // READ: Deny all client-side reads.
      allow get: if false;
      allow list: if false;

      // WRITE: Deny all client-side writes.
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
