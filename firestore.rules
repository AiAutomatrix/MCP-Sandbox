/**
 * This Firestore Security Ruleset is designed for the MCP agent sandbox application.
 *
 * Core Philosophy:
 * The rules enforce a strict user-ownership model. All user-generated data,
 * such as sessions, to-do items, and agent logs, is sandboxed within a
 * user-specific path (`/users/{userId}`). This prevents any user from accessing
 * another user's data.
 *
 * Data Structure:
 * - /users/{userId}/...: A hierarchical structure containing all data private
 *   to a single user. This includes their to-do lists, agent sessions, and
 *   all associated logs and memory facts for those sessions.
 * - /tool_memory/{toolName}/{dataId}: A top-level collection intended to store
 *   data generated by backend tools. This data is public and read-only for
 *   all clients.
 *
 * Key Security Decisions:
 * - Path-Based Ownership: Authorization relies entirely on the `{userId}` wildcard
 *   in the document path, making rules simple, performant, and secure without
 *   requiring extra database reads (`get()` calls).
 * - No User Listing: There are no rules for the `/users` collection itself,
 *   making it impossible for clients to list all users of the application.
 * - Public Read-Only for Tool Data: The `/tool_memory` collection is readable by
 *   anyone, but cannot be written to by clients. This allows the application to
 *   display tool-generated data while ensuring that only trusted backend
 *   processes (using the Admin SDK) can create or modify it.
 * - Prototyping Flexibility: These rules strictly enforce who can access data but
 *   do not validate the shape or type of the data being written. This allows for
 *   rapid development and iteration on the data model.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    //-------------------------------------------------------------------------
    // Helper Functions
    //-------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document.
     * Ensures that update and delete operations target a real document.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    //-------------------------------------------------------------------------
    // User Data Collections
    //-------------------------------------------------------------------------

    /**
     * @description Controls access to a user's to-do items. Only the owner can
     *              read, create, update, or delete their own items.
     * @path        /users/{userId}/todos/{todoId}
     * @allow       A user with auth.uid = 'user_abc' can (create) a new document at
     *              `/users/user_abc/todos/my_task`.
     * @deny        A user with auth.uid = 'user_xyz' is blocked from (get)ting
     *              `/users/user_abc/todos/some_task`.
     * @principle   Restricts access to a user's own data tree.
     */
    match /users/{userId}/todos/{todoId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's session documents. Sessions are
     *              private and can only be managed by their owner.
     * @path        /users/{userId}/sessions/{sessionId}
     * @allow       A user with auth.uid = 'user_abc' can (create) a new session at
     *              `/users/user_abc/sessions/session_123`.
     * @deny        An anonymous user is blocked from (list)ing sessions at
     *              `/users/user_abc/sessions`.
     * @principle   Restricts access to a user's own data tree.
     */
    match /users/{userId}/sessions/{sessionId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures agent logs nested under a user's session. Access is
     *              granted based on ownership of the parent user document.
     * @path        /users/{userId}/sessions/{sessionId}/agent_logs/{stepId}
     * @allow       The owner 'user_abc' can (get) a log step at
     *              `/users/user_abc/sessions/session_123/agent_logs/log_xyz`.
     * @deny        User 'user_xyz' cannot (create) a log step at
     *              `/users/user_abc/sessions/session_123/agent_logs/log_xyz`.
     * @principle   Inherits ownership from the parent path for nested subcollections.
     */
    match /users/{userId}/sessions/{sessionId}/agent_logs/{stepId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures agent memory facts under a user's session. Access is
     *              granted based on ownership of the parent user document.
     * @path        /users/{userId}/sessions/{sessionId}/agent_memory/{factId}
     * @allow       The owner 'user_abc' can (list) memory facts from
     *              `/users/user_abc/sessions/session_123/agent_memory`.
     * @deny        An anonymous user cannot (delete) a memory fact at
     *              `/users/user_abc/sessions/session_123/agent_memory/fact_456`.
     * @principle   Inherits ownership from the parent path for nested subcollections.
     */
    match /users/{userId}/sessions/{sessionId}/agent_memory/{factId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    //-------------------------------------------------------------------------
    // Public Collections
    //-------------------------------------------------------------------------

    /**
     * @description Provides public, read-only access to data stored by backend
     *              tools. Client applications cannot write to this collection.
     * @path        /tool_memory/{toolName}/{dataId}
     * @allow       Any user (authenticated or not) can (get) or (list) documents, e.g.,
     *              `/tool_memory/calculator/result_123`.
     * @deny        No user, including authenticated ones, can (create), (update),
     *              or (delete) documents in this collection.
     * @principle   Provides public read access while preventing client-side writes,
     *              reserving write permissions for trusted backend environments.
     */
    match /tool_memory/{toolName}/{dataId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}